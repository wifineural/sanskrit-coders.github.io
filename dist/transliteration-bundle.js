var module_transliteration =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/transliteration.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/query.js":
/*!*********************!*\
  !*** ./js/query.js ***!
  \*********************/
/*! exports provided: insertQueryParam, getQueryVariable */
/*! exports used: getQueryVariable, insertQueryParam */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return insertQueryParam; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getQueryVariable; });\n\nfunction insertQueryParam(key, value)\n{\n    key = encodeURI(key); value = encodeURI(value);\n\n    var kvp = document.location.search.substr(1).split('&');\n\n    var i=kvp.length; var x; while(i--)\n{\n    x = kvp[i].split('=');\n\n    if (x[0]==key)\n    {\n        x[1] = value;\n        kvp[i] = x.join('=');\n        break;\n    }\n}\n\n    if(i<0) {kvp[kvp.length] = [key,value].join('=');}\n\n    //this will reload the page, it's likely better to store this until finished\n    document.location.search = kvp.join('&');\n}\n\nfunction getQueryVariable(variable) {\n    var query = window.location.search.substring(1);\n    var vars = query.split('&');\n    for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split('=');\n        if (decodeURIComponent(pair[0]) === variable) {\n            return decodeURIComponent(pair[1]);\n        }\n    }\n    console.log('Query variable %s not found', variable);\n}\n\n\n//# sourceURL=webpack://module_%5Bname%5D/./js/query.js?");

/***/ }),

/***/ "./js/transliteration.js":
/*!*******************************!*\
  !*** ./js/transliteration.js ***!
  \*******************************/
/*! exports provided: saveLipi, transliterateDevanagariBody, updateTransliteration */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveLipi\", function() { return saveLipi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transliterateDevanagariBody\", function() { return transliterateDevanagariBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateTransliteration\", function() { return updateTransliteration; });\n/* harmony import */ var _sanskrit_coders_sanscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanskrit-coders/sanscript */ \"./node_modules/@sanskrit-coders/sanscript/sanscript.js\");\n/* harmony import */ var _sanskrit_coders_sanscript__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sanskrit_coders_sanscript__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./js/utils.js\");\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query */ \"./js/query.js\");\n\n\n\n\nlet transliterationTarget = \"devanagari\";\nlet previousTransliterationTarget = transliterationTarget;\nlet transliterationSource = pageParams.unicode_script || \"devanagari\";\n/* ---- Cookies ---- */\nlet LIPI_DEFAULT = \"devanagari\";\nlet LIPI_COOKIE = \"translitration_target\";\nlet LIPI_EXPIRY = 30 * 24 * 3600 * 1000;  // 30 days\n\nfunction loadLipi() {\n    let previousTransliterationTarget = transliterationTarget;\n    transliterationTarget = _query__WEBPACK_IMPORTED_MODULE_2__[/* getQueryVariable */ \"a\"](\"translitration_target\");\n    if (!transliterationTarget) {\n        transliterationTarget = _utils__WEBPACK_IMPORTED_MODULE_1__[/* getCookie */ \"a\"](LIPI_COOKIE) || LIPI_DEFAULT;\n    }\n    var translitrationTargetDropdown = document.getElementsByName(\"transliterationDropdown\")[0];\n    translitrationTargetDropdown.value = transliterationTarget;\n    console.log(transliterationTarget);\n}\n\nfunction saveLipi(lipi) {\n    transliterationTarget = lipi || LIPI_DEFAULT;\n    var date = new Date();\n    date.setTime(date.getTime() + LIPI_EXPIRY);\n    var addendum = \"; expires=\" + date.toGMTString() + \"; path=/\";\n    document.cookie = LIPI_COOKIE + \"=\" + transliterationTarget + addendum;\n}\n\n\nfunction transliterateDevanagariBody() {\n    loadLipi();\n    if (!transliterationTarget || previousTransliterationTarget == transliterationTarget) {\n        return;\n    }\n    \n    var textNodes = _utils__WEBPACK_IMPORTED_MODULE_1__[/* textNodesUnder */ \"b\"](document.getElementsByTagName(\"body\")[0]);\n    // console.debug(textNodes);\n    textNodes.forEach(function (textNode) {\n        if(textNode.parentNode.nodeName.toLowerCase() != \"option\") {\n            textNode.textContent = _sanskrit_coders_sanscript__WEBPACK_IMPORTED_MODULE_0___default.a.t(textNode.textContent, transliterationSource, transliterationTarget);\n        }\n    })\n}\n\nfunction updateTransliteration() {\n    var translitrationTargetDropdown = document.getElementsByName(\"transliterationDropdown\")[0];\n    var translitrationTarget = translitrationTargetDropdown.options[translitrationTargetDropdown.selectedIndex].value;\n    saveLipi(translitrationTarget);\n    _query__WEBPACK_IMPORTED_MODULE_2__[/* insertQueryParam */ \"b\"](\"translitration_target\", translitrationTarget);\n}\n\n\n\n//# sourceURL=webpack://module_%5Bname%5D/./js/transliteration.js?");

/***/ }),

/***/ "./js/utils.js":
/*!*********************!*\
  !*** ./js/utils.js ***!
  \*********************/
/*! exports provided: textNodesUnder, getCookie */
/*! exports used: getCookie, textNodesUnder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return textNodesUnder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getCookie; });\n\nfunction textNodesUnder(node){\n    var all = [];\n    for (node=node.firstChild;node;node=node.nextSibling){\n        if (node.nodeType==3) all.push(node);\n        else all = all.concat(textNodesUnder(node));\n    }\n    return all;\n}\n\nfunction getCookie(cname) {\n    var name = cname + \"=\";\n    var decodedCookie = decodeURIComponent(document.cookie);\n    var ca = decodedCookie.split(';');\n    for(var i = 0; i <ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0) == ' ') {\n            c = c.substring(1);\n        }\n        if (c.indexOf(name) == 0) {\n            return c.substring(name.length, c.length);\n        }\n    }\n    return undefined;\n}\n\n//# sourceURL=webpack://module_%5Bname%5D/./js/utils.js?");

/***/ }),

/***/ "./node_modules/@sanskrit-coders/sanscript/sanscript.js":
/*!**************************************************************!*\
  !*** ./node_modules/@sanskrit-coders/sanscript/sanscript.js ***!
  \**************************************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Sanscript\n *\n * Sanscript is a Sanskrit transliteration library. Currently, it supports\n * other Indian languages only incidentally.\n *\n * License: MIT\n */\n\nfunction exportSanscriptSingleton(global){\n    \"use strict\";\n\n    var Sanscript = {};\n    // First, we define the Sanscript singleton, with its variables and methods.\n    Sanscript.defaults = {\n        \"skip_sgml\": false,\n        \"syncope\": false\n    };\n\n    /* Schemes\n     * =======\n     * Schemes are of two kinds: \"Brahmic\" and \"roman.\" \"Brahmic\" schemes\n     * describe abugida scripts found in India. \"Roman\" schemes describe\n     * manufactured alphabets that are meant to describe or encode Brahmi\n     * scripts. Abugidas and alphabets are processed by separate algorithms\n     * because of the unique difficulties involved with each.\n     *\n     * Brahmic consonants are stated without a virama. Roman consonants are\n     * stated without the vowel 'a'.\n     *\n     * (Since \"abugida\" is not a well-known term, Sanscript uses \"Brahmic\"\n     * and \"roman\" for clarity.)\n     */\n    var schemes = Sanscript.schemes = {\n\n        /* Bengali\n         * -------\n         * 'va' and 'ba' are both rendered as ব.\n         */\n        \"bengali\": {\n            \"vowels\": [\"অ\", \"আ\", \"ই\", \"ঈ\", \"উ\", \"ঊ\", \"ঋ\", \"ৠ\", \"ঌ\", \"ৡ\", \"\", \"এ\", \"ঐ\", \"\", \"ও\", \"ঔ\"],\n            \"vowel_marks\": [\"া\", \"ি\", \"ী\", \"ু\", \"ূ\", \"ৃ\", \"ৄ\", \"ৢ\", \"ৣ\", \"\", \"ে\", \"ৈ\", \"\", \"ো\", \"ৌ\"],\n            \"other_marks\": [\"ং\", \"ঃ\", \"ঁ\"],\n            \"virama\": [\"্\"],\n            \"consonants\": [\"ক\", \"খ\", \"গ\", \"ঘ\", \"ঙ\", \"চ\", \"ছ\", \"জ\", \"ঝ\", \"ঞ\", \"ট\", \"ঠ\", \"ড\", \"ঢ\", \"ণ\", \"ত\", \"থ\", \"দ\", \"ধ\", \"ন\", \"প\", \"ফ\", \"ব\", \"ভ\", \"ম\", \"য\", \"র\", \"ল\", \"ব\", \"শ\", \"ষ\", \"স\", \"হ\", \"ळ\", \"ক্ষ\", \"জ্ঞ\"],\n            \"symbols\": [\"০\", \"১\", \"২\", \"৩\", \"৪\", \"৫\", \"৬\", \"৭\", \"৮\", \"৯\", \"ॐ\", \"ঽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"ড\", \"ঢ\", \"\", \"য\", \"\"]\n        },\n\n        /* Devanagari\n         * ----------\n         * The most comprehensive and unambiguous Brahmic script listed.\n         */\n        \"devanagari\": {\n            // \"Independent\" forms of the vowels. These are used whenever the\n            // vowel does not immediately follow a consonant.\n            \"vowels\": [\"अ\", \"आ\", \"इ\", \"ई\", \"उ\", \"ऊ\", \"ऋ\", \"ॠ\", \"ऌ\", \"ॡ\", \"ऎ\", \"ए\", \"ऐ\", \"ऒ\", \"ओ\", \"औ\"],\n\n            // \"Dependent\" forms of the vowels. These are used whenever the\n            // vowel immediately follows a consonant. If a letter is not\n            // listed in `vowels`, it should not be listed here.\n            \"vowel_marks\": [\"ा\", \"ि\", \"ी\", \"ु\", \"ू\", \"ृ\", \"ॄ\", \"ॢ\", \"ॣ\", \"ॆ\", \"े\", \"ै\", \"ॊ\", \"ो\", \"ौ\"],\n\n            // Miscellaneous marks, all of which are used in Sanskrit.\n            \"other_marks\": [\"ं\", \"ः\", \"ँ\"],\n\n            // In syllabic scripts like Devanagari, consonants have an inherent\n            // vowel that must be suppressed explicitly. We do so by putting a\n            // virama after the consonant.\n            \"virama\": [\"्\"],\n\n            // Various Sanskrit consonants and consonant clusters. Every token\n            // here has an explicit vowel. Thus \"क\" is \"ka\" instead of \"k\".\n            \"consonants\": [\"क\", \"ख\", \"ग\", \"घ\", \"ङ\", \"च\", \"छ\", \"ज\", \"झ\", \"ञ\", \"ट\", \"ठ\", \"ड\", \"ढ\", \"ण\", \"त\", \"थ\", \"द\", \"ध\", \"न\", \"प\", \"फ\", \"ब\", \"भ\", \"म\", \"य\", \"र\", \"ल\", \"व\", \"श\", \"ष\", \"स\", \"ह\", \"ळ\", \"क्ष\", \"ज्ञ\"],\n\n            // Numbers and punctuation\n            \"symbols\": [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\", \"ॐ\", \"ऽ\", \"।\", \"॥\"],\n\n            // Zero-width joiner. This is used to separate a consonant cluster\n            // and avoid a complex ligature.\n            \"zwj\": [\"\\u200D\"],\n\n            // Dummy consonant. This is used in ITRANS to prevert certain types\n            // of parser ambiguity. Thus \"barau\" -> बरौ but \"bara_u\" -> बरउ.\n            \"skip\": [\"\"],\n\n            // Vedic accent. Udatta and anudatta.\n            \"accent\": [\"\\u0951\", \"\\u0952\"],\n\n            // Accent combined with anusvara and and visarga. For compatibility\n            // with ITRANS, which allows the reverse of these four.\n            \"combo_accent\": [\"ः॑\", \"ः॒\", \"ं॑\", \"ं॒\"],\n\n            \"candra\": [\"ॅ\"],\n\n            // Non-Sanskrit consonants\n            \"other\": [\"क़\", \"ख़\", \"ग़\", \"ज़\", \"ड़\", \"ढ़\", \"फ़\", \"य़\", \"ऱ\"]\n        },\n\n        /* Gujarati\n         * --------\n         * Sanskrit-complete.\n         */\n        \"gujarati\": {\n            \"vowels\": [\"અ\", \"આ\", \"ઇ\", \"ઈ\", \"ઉ\", \"ઊ\", \"ઋ\", \"ૠ\", \"ઌ\", \"ૡ\", \"\", \"એ\", \"ઐ\", \"\", \"ઓ\", \"ઔ\"],\n            \"vowel_marks\": [\"ા\", \"િ\", \"ી\", \"ુ\", \"ૂ\", \"ૃ\", \"ૄ\", \"ૢ\", \"ૣ\", \"\", \"ે\", \"ૈ\", \"\", \"ો\", \"ૌ\"],\n            \"other_marks\": [\"ં\", \"ઃ\", \"ઁ\"],\n            \"virama\": [\"્\"],\n            \"consonants\": [\"ક\", \"ખ\", \"ગ\", \"ઘ\", \"ઙ\", \"ચ\", \"છ\", \"જ\", \"ઝ\", \"ઞ\", \"ટ\", \"ઠ\", \"ડ\", \"ઢ\", \"ણ\", \"ત\", \"થ\", \"દ\", \"ધ\", \"ન\", \"પ\", \"ફ\", \"બ\", \"ભ\", \"મ\", \"ય\", \"ર\", \"લ\", \"વ\", \"શ\", \"ષ\", \"સ\", \"હ\", \"ળ\", \"ક્ષ\", \"જ્ઞ\"],\n            \"symbols\": [\"૦\", \"૧\", \"૨\", \"૩\", \"૪\", \"૫\", \"૬\", \"૭\", \"૮\", \"૯\", \"ૐ\", \"ઽ\", \"૤\", \"૥\"],\n            \"candra\": [\"ૅ\"]\n        },\n\n        /* Gurmukhi\n         * --------\n         * Missing R/RR/lR/lRR\n         */\n        \"gurmukhi\": {\n            \"vowels\": [\"ਅ\", \"ਆ\", \"ਇ\", \"ਈ\", \"ਉ\", \"ਊ\", \"\", \"\", \"\", \"\", \"\", \"ਏ\", \"ਐ\", \"\", \"ਓ\", \"ਔ\"],\n            \"vowel_marks\": [\"ਾ\", \"ਿ\", \"ੀ\", \"ੁ\", \"ੂ\", \"\", \"\", \"\", \"\", \"\", \"ੇ\", \"ੈ\", \"\", \"ੋ\", \"ੌ\"],\n            \"other_marks\": [\"ਂ\", \"ਃ\", \"ਁ\"],\n            \"virama\": [\"੍\"],\n            \"consonants\": [\"ਕ\", \"ਖ\", \"ਗ\", \"ਘ\", \"ਙ\", \"ਚ\", \"ਛ\", \"ਜ\", \"ਝ\", \"ਞ\", \"ਟ\", \"ਠ\", \"ਡ\", \"ਢ\", \"ਣ\", \"ਤ\", \"ਥ\", \"ਦ\", \"ਧ\", \"ਨ\", \"ਪ\", \"ਫ\", \"ਬ\", \"ਭ\", \"ਮ\", \"ਯ\", \"ਰ\", \"ਲ\", \"ਵ\", \"ਸ਼\", \"ਸ਼\", \"ਸ\", \"ਹ\", \"ਲ਼\", \"ਕ੍ਸ਼\", \"ਜ੍ਞ\"],\n            \"symbols\": [\"੦\", \"੧\", \"੨\", \"੩\", \"੪\", \"੫\", \"੬\", \"੭\", \"੮\", \"੯\", \"ॐ\", \"ऽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"ਖ\", \"ਗ\", \"ਜ\", \"ਡ\", \"\", \"ਫ\", \"\", \"\"]\n        },\n\n        /* Kannada\n         * -------\n         * Sanskrit-complete.\n         */\n        \"kannada\": {\n            \"vowels\": [\"ಅ\", \"ಆ\", \"ಇ\", \"ಈ\", \"ಉ\", \"ಊ\", \"ಋ\", \"ೠ\", \"ಌ\", \"ೡ\", \"ಎ\", \"ಏ\", \"ಐ\", \"ಒ\", \"ಓ\", \"ಔ\"],\n            \"vowel_marks\": [\"ಾ\", \"ಿ\", \"ೀ\", \"ು\", \"ೂ\", \"ೃ\", \"ೄ\", \"ೢ\", \"ೣ\", \"ೆ\", \"ೇ\", \"ೈ\", \"ೊ\", \"ೋ\", \"ೌ\"],\n            \"other_marks\": [\"ಂ\", \"ಃ\", \"ँ\"],\n            \"virama\": [\"್\"],\n            \"consonants\": [\"ಕ\", \"ಖ\", \"ಗ\", \"ಘ\", \"ಙ\", \"ಚ\", \"ಛ\", \"ಜ\", \"ಝ\", \"ಞ\", \"ಟ\", \"ಠ\", \"ಡ\", \"ಢ\", \"ಣ\", \"ತ\", \"ಥ\", \"ದ\", \"ಧ\", \"ನ\", \"ಪ\", \"ಫ\", \"ಬ\", \"ಭ\", \"ಮ\", \"ಯ\", \"ರ\", \"ಲ\", \"ವ\", \"ಶ\", \"ಷ\", \"ಸ\", \"ಹ\", \"ಳ\", \"ಕ್ಷ\", \"ಜ್ಞ\"],\n            \"symbols\": [\"೦\", \"೧\", \"೨\", \"೩\", \"೪\", \"೫\", \"೬\", \"೭\", \"೮\", \"೯\", \"ಓಂ\", \"ಽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"\", \"\", \"ಫ\", \"\", \"ಱ\"]\n        },\n\n        /* Malayalam\n         * ---------\n         * Sanskrit-complete.\n         */\n        \"malayalam\": {\n            \"vowels\": [\"അ\", \"ആ\", \"ഇ\", \"ഈ\", \"ഉ\", \"ഊ\", \"ഋ\", \"ൠ\", \"ഌ\", \"ൡ\", \"എ\", \"ഏ\", \"ഐ\", \"ഒ\", \"ഓ\", \"ഔ\"],\n            \"vowel_marks\": [\"ാ\", \"ി\", \"ീ\", \"ു\", \"ൂ\", \"ൃ\", \"ൄ\", \"ൢ\", \"ൣ\", \"െ\", \"േ\", \"ൈ\", \"ൊ\", \"ോ\", \"ൌ\"],\n            \"other_marks\": [\"ം\", \"ഃ\", \"ँ\"],\n            \"virama\": [\"്\"],\n            \"consonants\": [\"ക\", \"ഖ\", \"ഗ\", \"ഘ\", \"ങ\", \"ച\", \"ഛ\", \"ജ\", \"ഝ\", \"ഞ\", \"ട\", \"ഠ\", \"ഡ\", \"ഢ\", \"ണ\", \"ത\", \"ഥ\", \"ദ\", \"ധ\", \"ന\", \"പ\", \"ഫ\", \"ബ\", \"ഭ\", \"മ\", \"യ\", \"ര\", \"ല\", \"വ\", \"ശ\", \"ഷ\", \"സ\", \"ഹ\", \"ള\", \"ക്ഷ\", \"ജ്ഞ\"],\n            \"symbols\": [\"൦\", \"൧\", \"൨\", \"൩\", \"൪\", \"൫\", \"൬\", \"൭\", \"൮\", \"൯\", \"ഓം\", \"ഽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"റ\"]\n        },\n\n        /* Oriya\n         * -----\n         * Sanskrit-complete.\n         */\n        \"oriya\": {\n            \"vowels\": [\"ଅ\", \"ଆ\", \"ଇ\", \"ଈ\", \"ଉ\", \"ଊ\", \"ଋ\", \"ୠ\", \"ଌ\", \"ୡ\", \"\", \"ଏ\", \"ଐ\", \"\", \"ଓ\", \"ଔ\"],\n            \"vowel_marks\": [\"ା\", \"ି\", \"ୀ\", \"ୁ\", \"ୂ\", \"ୃ\", \"ୄ\", \"ୢ\", \"ୣ\", \"\", \"େ\", \"ୈ\", \"\", \"ୋ\", \"ୌ\"],\n            \"other_marks\": [\"ଂ\", \"ଃ\", \"ଁ\"],\n            \"virama\": [\"୍\"],\n            \"consonants\": [\"କ\", \"ଖ\", \"ଗ\", \"ଘ\", \"ଙ\", \"ଚ\", \"ଛ\", \"ଜ\", \"ଝ\", \"ଞ\", \"ଟ\", \"ଠ\", \"ଡ\", \"ଢ\", \"ଣ\", \"ତ\", \"ଥ\", \"ଦ\", \"ଧ\", \"ନ\", \"ପ\", \"ଫ\", \"ବ\", \"ଭ\", \"ମ\", \"ଯ\", \"ର\", \"ଲ\", \"ଵ\", \"ଶ\", \"ଷ\", \"ସ\", \"ହ\", \"ଳ\", \"କ୍ଷ\", \"ଜ୍ଞ\"],\n            \"symbols\": [\"୦\", \"୧\", \"୨\", \"୩\", \"୪\", \"୫\", \"୬\", \"୭\", \"୮\", \"୯\", \"ଓଂ\", \"ଽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"ଡ\", \"ଢ\", \"\", \"ଯ\", \"\"]\n        },\n\n        /* Tamil\n         * -----\n         * Missing R/RR/lR/lRR vowel marks and voice/aspiration distinctions.\n         * The most incomplete of the Sanskrit schemes here.\n         */\n        \"tamil\": {\n            \"vowels\": [\"அ\", \"ஆ\", \"இ\", \"ஈ\", \"உ\", \"ஊ\", \"\", \"\", \"\", \"\", \"எ\", \"ஏ\", \"ஐ\", \"ஒ\", \"ஓ\", \"ஔ\"],\n            \"vowel_marks\": [\"ா\", \"ி\", \"ீ\", \"ு\", \"ூ\", \"\", \"\", \"\", \"\", \"ெ\", \"ே\", \"ை\", \"ொ\", \"ோ\", \"ௌ\"],\n            \"other_marks\": [\"ஂ\", \"ஃ\", \"\"],\n            \"virama\": [\"்\"],\n            \"consonants\": [\"க\", \"க\", \"க\", \"க\", \"ங\", \"ச\", \"ச\", \"ஜ\", \"ச\", \"ஞ\", \"ட\", \"ட\", \"ட\", \"ட\", \"ண\", \"த\", \"த\", \"த\", \"த\", \"ந\", \"ப\", \"ப\", \"ப\", \"ப\", \"ம\", \"ய\", \"ர\", \"ல\", \"வ\", \"ஶ\", \"ஷ\", \"ஸ\", \"ஹ\", \"ள\", \"க்ஷ\", \"ஜ்ஞ\"],\n            \"symbols\": [\"௦\", \"௧\", \"௨\", \"௩\", \"௪\", \"௫\", \"௬\", \"௭\", \"௮\", \"௯\", \"ௐ\", \"ऽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"ற\"]\n        },\n\n        /* Telugu\n         * ------\n         * Sanskrit-complete.\n         */\n        \"telugu\": {\n            \"vowels\": [\"అ\", \"ఆ\", \"ఇ\", \"ఈ\", \"ఉ\", \"ఊ\", \"ఋ\", \"ౠ\", \"ఌ\", \"ౡ\", \"ఎ\", \"ఏ\", \"ఐ\", \"ఒ\", \"ఓ\", \"ఔ\"],\n            \"vowel_marks\": [\"ా\", \"ి\", \"ీ\", \"ు\", \"ూ\", \"ృ\", \"ౄ\", \"ౢ\", \"ౣ\", \"ె\", \"ే\", \"ై\", \"ొ\", \"ో\", \"ౌ\"],\n            \"other_marks\": [\"ం\", \"ః\", \"ఁ\"],\n            \"virama\": [\"్\"],\n            \"consonants\": [\"క\", \"ఖ\", \"గ\", \"ఘ\", \"ఙ\", \"చ\", \"ఛ\", \"జ\", \"ఝ\", \"ఞ\", \"ట\", \"ఠ\", \"డ\", \"ఢ\", \"ణ\", \"త\", \"థ\", \"ద\", \"ధ\", \"న\", \"ప\", \"ఫ\", \"బ\", \"భ\", \"మ\", \"య\", \"ర\", \"ల\", \"వ\", \"శ\", \"ష\", \"స\", \"హ\", \"ళ\", \"క్ష\", \"జ్ఞ\"],\n            \"symbols\": [\"౦\", \"౧\", \"౨\", \"౩\", \"౪\", \"౫\", \"౬\", \"౭\", \"౮\", \"౯\", \"ఓం\", \"ఽ\", \"।\", \"॥\"],\n            \"other\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"ఱ\"]\n        },\n\n        /* International Alphabet of Sanskrit Transliteration\n         * --------------------------------------------------\n         * The most \"professional\" Sanskrit romanization scheme.\n         */\n        \"iast\": {\n            \"vowels\": [\"a\", \"ā\", \"i\", \"ī\", \"u\", \"ū\", \"ṛ\", \"ṝ\", \"ḷ\", \"ḹ\", \"\", \"e\", \"ai\", \"\", \"o\", \"au\"],\n            \"other_marks\": [\"ṃ\", \"ḥ\", \"~\"],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"kh\", \"g\", \"gh\", \"ṅ\", \"c\", \"ch\", \"j\", \"jh\", \"ñ\", \"ṭ\", \"ṭh\", \"ḍ\", \"ḍh\", \"ṇ\", \"t\", \"th\", \"d\", \"dh\", \"n\", \"p\", \"ph\", \"b\", \"bh\", \"m\", \"y\", \"r\", \"l\", \"v\", \"ś\", \"ṣ\", \"s\", \"h\", \"ḻ\", \"kṣ\", \"jñ\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"oṃ\", \"'\", \"।\", \"॥\"]\n        },\n\n        /* ITRANS\n         * ------\n         * One of the first romanization schemes -- and one of the most\n         * complicated. For alternate forms, see the \"allAlternates\" variable\n         * below.\n         *\n         * '_' is a \"null\" letter, which allows adjacent vowels.\n         */\n        \"itrans\": {\n            \"vowels\": [\"a\", \"A\", \"i\", \"I\", \"u\", \"U\", \"RRi\", \"RRI\", \"LLi\", \"LLI\", \"\", \"e\", \"ai\", \"\", \"o\", \"au\"],\n            \"other_marks\": [\"M\", \"H\", \".N\"],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"kh\", \"g\", \"gh\", \"~N\", \"ch\", \"Ch\", \"j\", \"jh\", \"~n\", \"T\", \"Th\", \"D\", \"Dh\", \"N\", \"t\", \"th\", \"d\", \"dh\", \"n\", \"p\", \"ph\", \"b\", \"bh\", \"m\", \"y\", \"r\", \"l\", \"v\", \"sh\", \"Sh\", \"s\", \"h\", \"L\", \"kSh\", \"j~n\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"OM\", \".a\", \"|\", \"||\"],\n            \"candra\": [\".c\"],\n            \"zwj\": [\"{}\"],\n            \"skip\": \"_\",\n            \"accent\": [\"\\\\'\", \"\\\\_\"],\n            \"combo_accent\": [\"\\\\'H\", \"\\\\_H\", \"\\\\'M\", \"\\\\_M\"],\n            \"other\": [\"q\", \"K\", \"G\", \"z\", \".D\", \".Dh\", \"f\", \"Y\", \"R\"]\n        },\n\n        /* Harvard-Kyoto\n         * -------------\n         * A simple 1:1 mapping.\n         */\n        \"hk\": {\n            \"vowels\": [\"a\", \"A\", \"i\", \"I\", \"u\", \"U\", \"R\", \"RR\", \"lR\", \"lRR\", \"\", \"e\", \"ai\", \"\", \"o\", \"au\"],\n            \"other_marks\": [\"M\", \"H\", \"~\",],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"kh\", \"g\", \"gh\", \"G\", \"c\", \"ch\", \"j\", \"jh\", \"J\", \"T\", \"Th\", \"D\", \"Dh\", \"N\", \"t\", \"th\", \"d\", \"dh\", \"n\", \"p\", \"ph\", \"b\", \"bh\", \"m\", \"y\", \"r\", \"l\", \"v\", \"z\", \"S\", \"s\", \"h\", \"L\", \"kS\", \"jJ\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"OM\", \"'\", \"|\", \"||\"]\n        },\n\n        /* National Library at Kolkata\n         * ---------------------------\n         * Apart from using \"ē\" and \"ō\" instead of \"e\" and \"o\", this scheme is\n         * identical to IAST. ṝ, ḷ, and ḹ are not part of the scheme proper.\n         *\n         * This is defined further below.\n         */\n\n        /* Sanskrit Library Phonetic Basic\n         * -------------------------------\n         * With one ASCII letter per phoneme, this is the tersest transliteration\n         * scheme in use today and is especially suited to computer processing.\n         */\n        \"slp1\": {\n            \"vowels\": [\"a\", \"A\", \"i\", \"I\", \"u\", \"U\", \"f\", \"F\", \"x\", \"X\", \"\", \"e\", \"E\", \"\", \"o\", \"O\"],\n            \"other_marks\": [\"M\", \"H\", \"~\"],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"K\", \"g\", \"G\", \"N\", \"c\", \"C\", \"j\", \"J\", \"Y\", \"w\", \"W\", \"q\", \"Q\", \"R\", \"t\", \"T\", \"d\", \"D\", \"n\", \"p\", \"P\", \"b\", \"B\", \"m\", \"y\", \"r\", \"l\", \"v\", \"S\", \"z\", \"s\", \"h\", \"L\", \"kz\", \"jY\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"oM\", \"'\", \".\", \"..\"]\n        },\n\n        /* Velthuis\n         * --------\n         * A case-insensitive Sanskrit encoding.\n         */\n        \"velthuis\": {\n            \"vowels\": [\"a\", \"aa\", \"i\", \"ii\", \"u\", \"uu\", \".r\", \".rr\", \".li\", \".ll\", \"\", \"e\", \"ai\", \"\", \"o\", \"au\"],\n            \"other_marks\": [\".m\", \".h\", \"\"],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"kh\", \"g\", \"gh\", \"\\\"n\", \"c\", \"ch\", \"j\", \"jh\", \"~n\", \".t\", \".th\", \".d\", \".d\", \".n\", \"t\", \"th\", \"d\", \"dh\", \"n\", \"p\", \"ph\", \"b\", \"bh\", \"m\", \"y\", \"r\", \"l\", \"v\", \"~s\", \".s\", \"s\", \"h\", \"L\", \"k.s\", \"j~n\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"o.m\", \"'\", \"|\", \"||\"]\n        },\n\n        /* WX\n         * --\n         * As terse as SLP1.\n         */\n        \"wx\": {\n            \"vowels\": [\"a\", \"A\", \"i\", \"I\", \"u\", \"U\", \"q\", \"Q\", \"L\", \"\", \"\", \"e\", \"E\", \"\", \"o\", \"O\"],\n            \"other_marks\": [\"M\", \"H\", \"z\"],\n            \"virama\": [\"\"],\n            \"consonants\": [\"k\", \"K\", \"g\", \"G\", \"f\", \"c\", \"C\", \"j\", \"J\", \"F\", \"t\", \"T\", \"d\", \"D\", \"N\", \"w\", \"W\", \"x\", \"X\", \"n\", \"p\", \"P\", \"b\", \"B\", \"m\", \"y\", \"r\", \"l\", \"v\", \"S\", \"R\", \"s\", \"h\", \"\", \"kR\", \"jF\"],\n            \"symbols\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"oM\", \"'\", \"|\", \"||\"]\n        },\n    },\n\n    // Set of names of schemes\n    romanSchemes = {},\n\n    // Map of alternate encodings.\n    allAlternates = {\n        \"itrans\": {\n            \"A\": [\"aa\"],\n            \"I\": [\"ii\", \"ee\"],\n            \"U\": [\"uu\", \"oo\"],\n            \"RRi\": [\"R^i\"],\n            \"RRI\": [\"R^I\"],\n            \"LLi\": [\"L^i\"],\n            \"LLI\": [\"L^I\"],\n            \"M\": [\".m\", \".n\"],\n            \"~N\": [\"N^\"],\n            \"ch\": [\"c\"],\n            \"Ch\": [\"C\", \"chh\"],\n            \"~n\": [\"JN\"],\n            \"v\": [\"w\"],\n            \"Sh\": [\"S\", \"shh\"],\n            \"kSh\": [\"kS\", \"x\"],\n            \"j~n\": [\"GY\", \"dny\"],\n            \"OM\": [\"AUM\"],\n            \"\\\\_\": [\"\\\\`\"],\n            \"\\\\_H\": [\"\\\\`H\"],\n            \"\\\\'M\": [\"\\\\'.m\", \"\\\\'.n\"],\n            \"\\\\_M\": [\"\\\\_.m\", \"\\\\_.n\", \"\\\\`M\", \"\\\\`.m\", \"\\\\`.n\"],\n            \".a\": [\"~\"],\n            \"|\": [\".\"],\n            \"||\": [\"..\"],\n            \"z\": [\"J\"]\n        }\n    },\n\n    // object cache\n    cache = {};\n\n    /**\n     * Check whether the given scheme encodes romanized Sanskrit.\n     *\n     * @param name  the scheme name\n     * @return      boolean\n     */\n    Sanscript.isRomanScheme = function(name) {\n        return romanSchemes.hasOwnProperty(name);\n    };\n\n    /**\n     * Add a Brahmic scheme to Sanscript.\n     *\n     * Schemes are of two types: \"Brahmic\" and \"roman\". Brahmic consonants\n     * have an inherent vowel sound, but roman consonants do not. This is the\n     * main difference between these two types of scheme.\n     *\n     * A scheme definition is an object (\"{}\") that maps a group name to a\n     * list of characters. For illustration, see the \"devanagari\" scheme at\n     * the top of this file.\n     *\n     * You can use whatever group names you like, but for the best results,\n     * you should use the same group names that Sanscript does.\n     *\n     * @param name    the scheme name\n     * @param scheme  the scheme data itself. This should be constructed as\n     *                described above.\n     */\n    Sanscript.addBrahmicScheme = function(name, scheme) {\n        Sanscript.schemes[name] = scheme;\n    };\n\n    /**\n     * Add a roman scheme to Sanscript.\n     *\n     * See the comments on Sanscript.addBrahmicScheme. The \"vowel_marks\" field\n     * can be omitted.\n     *\n     * @param name    the scheme name\n     * @param scheme  the scheme data itself\n     */\n    Sanscript.addRomanScheme = function(name, scheme) {\n        if (!('vowel_marks' in scheme)) {\n            scheme.vowel_marks = scheme.vowels.slice(1);\n        }\n        Sanscript.schemes[name] = scheme;\n        romanSchemes[name] = true;\n    };\n\n    /**\n     * Create a deep copy of an object, for certain kinds of objects.\n     *\n     * @param scheme  the scheme to copy\n     * @return        the copy\n     */\n    var cheapCopy = function(scheme) {\n        var copy = {};\n        for (var key in scheme) {\n            if (!scheme.hasOwnProperty(key)) {\n                continue;\n            }\n            copy[key] = scheme[key].slice(0);\n        }\n        return copy;\n    };\n\n    // Set up various schemes\n    (function() {\n        // Set up roman schemes\n        var kolkata = schemes.kolkata = cheapCopy(schemes.iast),\n            schemeNames = [\"iast\", \"itrans\", \"hk\", \"kolkata\", \"slp1\", \"velthuis\", \"wx\"];\n        kolkata.vowels = [\"a\", \"ā\", \"i\", \"ī\", \"u\", \"ū\", \"ṛ\", \"ṝ\", \"ḷ\", \"ḹ\", \"e\", \"ē\", \"ai\", \"o\", \"ō\", \"au\"];\n\n        // These schemes already belong to Sanscript.schemes. But by adding\n        // them again with `addRomanScheme`, we automatically build up\n        // `romanSchemes` and define a `vowel_marks` field for each one.\n        for (var i = 0, name; (name = schemeNames[i]); i++) {\n            Sanscript.addRomanScheme(name, schemes[name]);\n        }\n\n        // ITRANS variant, which supports Dravidian short 'e' and 'o'.\n        var itrans_dravidian = cheapCopy(schemes.itrans);\n        itrans_dravidian.vowels = [\"a\", \"A\", \"i\", \"I\", \"u\", \"U\", \"Ri\", \"RRI\", \"LLi\", \"LLi\", \"e\", \"E\", \"ai\", \"o\", \"O\", \"au\"];\n        itrans_dravidian.vowel_marks = itrans_dravidian.vowels.slice(1);\n        allAlternates.itrans_dravidian = allAlternates.itrans;\n        Sanscript.addRomanScheme('itrans_dravidian', itrans_dravidian);\n    }());\n\n    /**\n     * Create a map from every character in `from` to its partner in `to`.\n     * Also, store any \"marks\" that `from` might have.\n     *\n     * @param from     input scheme\n     * @param to       output scheme\n     * @param options  scheme options\n     */\n    var makeMap = function(from, to, options) {\n        var alternates = allAlternates[from] || {},\n            consonants = {},\n            fromScheme = Sanscript.schemes[from],\n            letters = {},\n            tokenLengths = [],\n            marks = {},\n            toScheme = Sanscript.schemes[to];\n\n        for (var group in fromScheme) {\n            if (!fromScheme.hasOwnProperty(group)) {\n                continue;\n            }\n            var fromGroup = fromScheme[group],\n                toGroup = toScheme[group];\n            if (toGroup === undefined) {\n                continue;\n            }\n            for (var i = 0; i < fromGroup.length; i++) {\n                var F = fromGroup[i],\n                    T = toGroup[i],\n                    alts = alternates[F] || [],\n                    numAlts = alts.length,\n                    j = 0;\n\n                tokenLengths.push(F.length);\n                for (j = 0; j < numAlts; j++) {\n                    tokenLengths.push(alts[j].length);\n                }\n\n                if (group === 'vowel_marks' || group === 'virama') {\n                    marks[F] = T;\n                    for (j = 0; j < numAlts; j++) {\n                        marks[alts[j]] = T;\n                    }\n                } else {\n                    letters[F] = T;\n                    for (j = 0; j < numAlts; j++) {\n                        letters[alts[j]] = T;\n                    }\n                    if (group === 'consonants' || group === 'other') {\n                        consonants[F] = T;\n\n                        for (j = 0; j < numAlts; j++) {\n                            consonants[alts[j]] = T;\n                        }\n                    }\n                }\n            }\n        }\n\n        return {consonants: consonants,\n            fromRoman: Sanscript.isRomanScheme(from),\n            letters: letters,\n            marks: marks,\n            maxTokenLength: Math.max.apply(Math, tokenLengths),\n            toRoman: Sanscript.isRomanScheme(to),\n            virama: toScheme.virama};\n    };\n\n    /**\n     * Transliterate from a romanized script.\n     *\n     * @param data     the string to transliterate\n     * @param map      map data generated from makeMap()\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    var transliterateRoman = function(data, map, options) {\n        var buf = [],\n            consonants = map.consonants,\n            dataLength = data.length,\n            hadConsonant = false,\n            letters = map.letters,\n            marks = map.marks,\n            maxTokenLength = map.maxTokenLength,\n            optSkipSGML = options.skip_sgml,\n            optSyncope = options.syncope,\n            tempLetter,\n            tempMark,\n            tokenBuffer = '',\n            toRoman = map.toRoman,\n            virama = map.virama;\n\n        // Transliteration state. It's controlled by these values:\n        // - `skippingSGML`: are we in SGML?\n        // - `toggledTrans`: are we in a toggled region?\n        //\n        // We combine these values into a single variable `skippingTrans`:\n        //\n        //     `skippingTrans` = skippingSGML || toggledTrans;\n        //\n        // If (and only if) this value is true, don't transliterate.\n        var skippingSGML = false,\n            skippingTrans = false,\n            toggledTrans = false;\n\n        for (var i = 0, L; (L = data.charAt(i)) || tokenBuffer; i++) {\n            // Fill the token buffer, if possible.\n            var difference = maxTokenLength - tokenBuffer.length;\n            if (difference > 0 && i < dataLength) {\n                tokenBuffer += L;\n                if (difference > 1) {\n                    continue;\n                }\n            }\n\n            // Match all token substrings to our map.\n            for (var j = 0; j < maxTokenLength; j++) {\n                var token = tokenBuffer.substr(0,maxTokenLength-j);\n\n                if (skippingSGML === true) {\n                    skippingSGML = (token !== '>');\n                } else if (token === '<') {\n                    skippingSGML = optSkipSGML;\n                } else if (token === '##') {\n                    toggledTrans = !toggledTrans;\n                    tokenBuffer = tokenBuffer.substr(2);\n                    break;\n                }\n                skippingTrans = skippingSGML || toggledTrans;\n                if ((tempLetter = letters[token]) !== undefined && !skippingTrans) {\n                    if (toRoman) {\n                        buf.push(tempLetter);\n                    } else {\n                        // Handle the implicit vowel. Ignore 'a' and force\n                        // vowels to appear as marks if we've just seen a\n                        // consonant.\n                        if (hadConsonant) {\n                            if ((tempMark = marks[token])) {\n                                buf.push(tempMark);\n                            } else if (token !== 'a') {\n                                buf.push(virama);\n                                buf.push(tempLetter);\n                            }\n                        } else {\n                            buf.push(tempLetter);\n                        }\n                        hadConsonant = token in consonants;\n                    }\n                    tokenBuffer = tokenBuffer.substr(maxTokenLength-j);\n                    break;\n                } else if (j === maxTokenLength - 1) {\n                    if (hadConsonant) {\n                        hadConsonant = false;\n                        if (!optSyncope) {\n                            buf.push(virama);\n                        }\n                    }\n                    buf.push(token);\n                    tokenBuffer = tokenBuffer.substr(1);\n                    // 'break' is redundant here, \"j == ...\" is true only on\n                    // the last iteration.\n                }\n            }\n        }\n        if (hadConsonant && !optSyncope) {\n            buf.push(virama);\n        }\n        return buf.join('');\n    };\n\n    /**\n     * Transliterate from a Brahmic script.\n     *\n     * @param data     the string to transliterate\n     * @param map      map data generated from makeMap()\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    var transliterateBrahmic = function(data, map, options) {\n        var buf = [],\n            consonants = map.consonants,\n            danglingHash = false,\n            hadRomanConsonant = false,\n            letters = map.letters,\n            marks = map.marks,\n            temp,\n            toRoman = map.toRoman,\n            skippingTrans = false;\n\n        for (var i = 0, L; (L = data.charAt(i)); i++) {\n            // Toggle transliteration state\n            if (L === '#') {\n                if (danglingHash) {\n                    skippingTrans = !skippingTrans;\n                    danglingHash = false;\n                } else {\n                    danglingHash = true;\n                }\n                if (hadRomanConsonant) {\n                    buf.push('a');\n                    hadRomanConsonant = false;\n                }\n                continue;\n            } else if (skippingTrans) {\n                buf.push(L);\n                continue;\n            }\n\n            if ((temp = marks[L]) !== undefined) {\n                buf.push(temp);\n                hadRomanConsonant = false;\n            } else {\n                if (danglingHash) {\n                    buf.push('#');\n                    danglingHash = false;\n                }\n                if (hadRomanConsonant) {\n                    buf.push('a');\n                    hadRomanConsonant = false;\n                }\n\n                // Push transliterated letter if possible. Otherwise, push\n                // the letter itself.\n                if ((temp = letters[L])) {\n                    buf.push(temp);\n                    hadRomanConsonant = toRoman && (L in consonants);\n                } else {\n                    buf.push(L);\n                }\n            }\n        }\n        if (hadRomanConsonant) {\n            buf.push('a');\n        }\n        return buf.join('');\n    };\n\n    /**\n     * Transliterate from one script to another.\n     *\n     * @param data     the string to transliterate\n     * @param from     the source script\n     * @param to       the destination script\n     * @param options  transliteration options\n     * @return         the finished string\n     */\n    Sanscript.t = function(data, from, to, options) {\n        options = options || {};\n        var cachedOptions = cache.options || {},\n            defaults = Sanscript.defaults,\n            hasPriorState = (cache.from === from && cache.to === to),\n            map;\n\n        // Here we simultaneously build up an `options` object and compare\n        // these options to the options from the last run.\n        for (var key in defaults) {\n            if (defaults.hasOwnProperty(key)) {\n                var value = defaults[key];\n                if (key in options) {\n                    value = options[key];\n                }\n                options[key] = value;\n\n                // This comparison method is not generalizable, but since these\n                // objects are associative arrays with identical keys and with\n                // values of known type, it works fine here.\n                if (value !== cachedOptions[key]) {\n                    hasPriorState = false;\n                }\n            }\n        }\n\n        if (hasPriorState) {\n            map = cache.map;\n        } else {\n            map = makeMap(from, to, options);\n            cache = {\n                from: from,\n                map: map,\n                options: options,\n                to: to};\n        }\n\n        // Easy way out for \"{\\m+}\", \"\\\", and \".h\".\n        if (from === 'itrans') {\n            data = data.replace(/\\{\\\\m\\+\\}/g, \".h.N\");\n            data = data.replace(/\\.h/g, '');\n            data = data.replace(/\\\\([^'`_]|$)/g, \"##$1##\");\n        }\n\n        if (map.fromRoman) {\n            return transliterateRoman(data, map, options);\n        } else {\n            return transliterateBrahmic(data, map, options);\n        }\n    };\n\n    // Now that Sanscript is fully defined, we now safely export it for use elsewhere.\n    // The below block was copied from https://www.npmjs.com/package/sanscript .\n    // define seems to be a requirejs thing https://requirejs.org/docs/whyamd.html#amd .\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return Sanscript; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n};\n\nexportSanscriptSingleton(this);\n\n\n//# sourceURL=webpack://module_%5Bname%5D/./node_modules/@sanskrit-coders/sanscript/sanscript.js?");

/***/ })

/******/ });